<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roam Filter Copy - Unit Tests</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      max-width: 900px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
    }
    .test-section {
      background: white;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .test-case {
      margin: 10px 0;
      padding: 10px;
      border-left: 4px solid #ccc;
    }
    .test-case.passed {
      border-left-color: #28a745;
      background: #f0fff4;
    }
    .test-case.failed {
      border-left-color: #dc3545;
      background: #fff5f5;
    }
    .test-name {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .test-result {
      font-size: 14px;
      color: #666;
    }
    .summary {
      background: #e9ecef;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      font-weight: bold;
    }
    .summary.all-passed {
      background: #d4edda;
      color: #155724;
    }
    .summary.some-failed {
      background: #f8d7da;
      color: #721c24;
    }
  </style>
</head>
<body>
  <h1>Roam Filter Copy - Unit Tests</h1>
  <div id="test-results"></div>
  <div id="summary"></div>

  <script>
    // Simple test framework
    class TestRunner {
      constructor() {
        this.tests = [];
        this.results = [];
      }

      test(name, fn) {
        this.tests.push({ name, fn });
      }

      async run() {
        for (const test of this.tests) {
          try {
            await test.fn();
            this.results.push({ name: test.name, passed: true });
          } catch (error) {
            this.results.push({ name: test.name, passed: false, error: error.message });
          }
        }
        this.displayResults();
      }

      displayResults() {
        const container = document.getElementById('test-results');
        const summaryDiv = document.getElementById('summary');

        let html = '';
        this.results.forEach(result => {
          const status = result.passed ? 'passed' : 'failed';
          const icon = result.passed ? '✓' : '✗';
          const errorMsg = result.error ? `<div class="test-result">Error: ${result.error}</div>` : '';

          html += `
            <div class="test-case ${status}">
              <div class="test-name">${icon} ${result.name}</div>
              ${errorMsg}
            </div>
          `;
        });

        container.innerHTML = `<div class="test-section">${html}</div>`;

        const passed = this.results.filter(r => r.passed).length;
        const total = this.results.length;
        const allPassed = passed === total;

        summaryDiv.innerHTML = `
          <div class="summary ${allPassed ? 'all-passed' : 'some-failed'}">
            Tests: ${passed}/${total} passed
          </div>
        `;
      }
    }

    // Helper function for assertions
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }

    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected}, but got ${actual}`);
      }
    }

    // Mock Roam API for testing
    window.roamAlphaAPI = {
      pull: (query, params) => {
        // Mock implementation for testing
        const uid = params[1];

        // Mock data for testing - includes nested structure for collapsed block testing
        const mockBlocks = {
          'test-uid-1': {
            ':block/string': 'Test Block 1',
            ':block/uid': 'test-uid-1',
            ':block/children': [
              { ':block/uid': 'test-uid-1-1', ':block/order': 0 }
            ]
          },
          'test-uid-1-1': {
            ':block/string': 'Child Block 1.1',
            ':block/uid': 'test-uid-1-1',
            ':block/children': []
          },
          'test-uid-2': {
            ':block/string': 'Test Block 2',
            ':block/uid': 'test-uid-2',
            ':block/children': []
          },
          'parent-collapsed': {
            ':block/string': 'Parent Collapsed',
            ':block/uid': 'parent-collapsed',
            ':block/children': [
              { ':block/uid': 'child-1', ':block/order': 0 },
              { ':block/uid': 'child-2', ':block/order': 1 }
            ]
          },
          'child-1': {
            ':block/string': 'Child 1',
            ':block/uid': 'child-1',
            ':block/children': [
              { ':block/uid': 'grandchild-1-1', ':block/order': 0 }
            ]
          },
          'child-2': {
            ':block/string': 'Child 2',
            ':block/uid': 'child-2',
            ':block/children': []
          },
          'grandchild-1-1': {
            ':block/string': 'Grandchild 1.1 #selected',
            ':block/uid': 'grandchild-1-1',
            ':block/children': []
          }
        };

        return mockBlocks[uid] || null;
      }
    };

    // Load the extension code (we need to inline it for testing)
  </script>

  <!-- Include the extension code here -->
  <script src="extension.js"></script>

  <script>
    // Run tests
    const runner = new TestRunner();

    // Test 1: isRoamAPIAvailable
    runner.test('isRoamAPIAvailable - should return true when API exists', () => {
      const result = isRoamAPIAvailable();
      assert(result === true, 'API should be available');
    });

    // Test 2: isRoamAPIAvailable with missing API
    runner.test('isRoamAPIAvailable - should return false when API is missing', () => {
      const originalAPI = window.roamAlphaAPI;
      window.roamAlphaAPI = null;
      const result = isRoamAPIAvailable();
      window.roamAlphaAPI = originalAPI;
      assert(result === false, 'API should not be available');
    });

    // Test 3: getBlockUidFromElement with null
    runner.test('getBlockUidFromElement - should handle null container', () => {
      const result = getBlockUidFromElement(null);
      assert(result === null, 'Should return null for null container');
    });

    // Test 4: getBlockUidFromElement with valid element
    runner.test('getBlockUidFromElement - should extract UID from element', () => {
      const div = document.createElement('div');
      const input = document.createElement('textarea');
      input.id = 'block-input-test-123-abc';
      div.appendChild(input);

      const result = getBlockUidFromElement(div);
      assertEqual(result, 'abc', 'Should extract UID correctly');
    });

    // Test 5: isDescendantOf with null parameters
    runner.test('isDescendantOf - should handle null parameters', () => {
      const result = isDescendantOf(null, null);
      assert(result === false, 'Should return false for null parameters');
    });

    // Test 6: isDescendantOf with valid elements
    runner.test('isDescendantOf - should detect descendant relationship', () => {
      const parent = document.createElement('div');
      const child = document.createElement('div');
      const grandchild = document.createElement('div');

      parent.appendChild(child);
      child.appendChild(grandchild);

      const result = isDescendantOf(grandchild, parent);
      assert(result === true, 'Grandchild should be descendant of parent');
    });

    // Test 7: isDescendantOf with non-descendant
    runner.test('isDescendantOf - should return false for non-descendants', () => {
      const div1 = document.createElement('div');
      const div2 = document.createElement('div');

      const result = isDescendantOf(div1, div2);
      assert(result === false, 'Unrelated elements should not be descendants');
    });



    // Test 11: getBlockChildren with valid UID
    runner.test('getBlockChildren - should retrieve block and children', () => {
      const lines = getBlockChildren('test-uid-1', 0);
      assert(lines.length > 0, 'Should return lines');
      assert(lines[0].includes('Test Block 1'), 'Should contain block content');
    });

    // Test 12: getBlockChildren with empty UID
    runner.test('getBlockChildren - should handle empty UID', () => {
      const lines = getBlockChildren('', 0);
      assert(lines.length === 0, 'Should return empty array for empty UID');
    });





    // Test 15: showNotification
    runner.test('showNotification - should create notification element', () => {
      showNotification('Test', '#137CBD');
      const notifications = document.querySelectorAll('div[style*="position: fixed"]');
      assert(notifications.length > 0, 'Should create notification');
    });

    // Test 16: getAllDescendantUids - should find all descendants
    runner.test('getAllDescendantUids - should find all descendants', () => {
      const descendants = getAllDescendantUids('parent-collapsed');
      assert(descendants.length === 3, `Should find 3 descendants, found ${descendants.length}`);
      assert(descendants.includes('child-1'), 'Should include child-1');
      assert(descendants.includes('child-2'), 'Should include child-2');
      assert(descendants.includes('grandchild-1-1'), 'Should include grandchild-1-1');
    });

    // Test 17: getAllDescendantUids - should handle empty UID
    runner.test('getAllDescendantUids - should handle empty UID', () => {
      const descendants = getAllDescendantUids('');
      assert(descendants.length === 0, 'Should return empty array for empty UID');
    });

    // Test 18: getAllDescendantUids - should handle non-existent UID
    runner.test('getAllDescendantUids - should handle non-existent UID', () => {
      const descendants = getAllDescendantUids('non-existent');
      assert(descendants.length === 0, 'Should return empty array for non-existent UID');
    });

    // Test 19: findSelectedDescendants - should find selected descendants
    runner.test('findSelectedDescendants - should find selected descendants', () => {
      const selectedUids = new Set(['grandchild-1-1']);
      const found = findSelectedDescendants('parent-collapsed', selectedUids);
      assert(found.length === 1, 'Should find 1 selected descendant');
      assert(found[0] === 'grandchild-1-1', 'Should find grandchild-1-1');
    });

    // Test 20: findSelectedDescendants - should return empty when no selection
    runner.test('findSelectedDescendants - should return empty when no selection', () => {
      const selectedUids = new Set(['non-existent-uid']);
      const found = findSelectedDescendants('parent-collapsed', selectedUids);
      assert(found.length === 0, 'Should return empty array when no descendants selected');
    });

    // Test 21: buildPathToDescendants - should build path to selected descendant
    runner.test('buildPathToDescendants - should build path to selected descendant', () => {
      const targetUids = new Set(['grandchild-1-1']);
      const lines = buildPathToDescendants('parent-collapsed', targetUids, 0);

      assert(lines.length > 0, 'Should return lines');

      // Should include parent
      const hasParent = lines.some(line => line.includes('Parent Collapsed'));
      assert(hasParent, 'Should include parent block');

      // Should include child-1 (on path to target)
      const hasChild1 = lines.some(line => line.includes('Child 1'));
      assert(hasChild1, 'Should include Child 1 on path to target');

      // Should include grandchild-1-1 (the target)
      const hasGrandchild = lines.some(line => line.includes('Grandchild 1.1'));
      assert(hasGrandchild, 'Should include target grandchild');

      // Should NOT include child-2 (not on path to target)
      const hasChild2 = lines.some(line => line.includes('Child 2'));
      assert(!hasChild2, 'Should NOT include Child 2 as it is not on path to target');
    });

    // Test 22: buildPathToDescendants - should handle empty target set
    runner.test('buildPathToDescendants - should handle empty target set', () => {
      const targetUids = new Set();
      const lines = buildPathToDescendants('parent-collapsed', targetUids, 0);
      assert(lines.length === 0, 'Should return empty array for empty target set');
    });

    // Run all tests
    runner.run();
  </script>
</body>
</html>
